/*
 * Secret Server
 *
 * This is an API of a secret service. You can save your secret by using the API. You can restrict the access of a secret after the certen number of views or after a certen period of time.
 *
 * API version: 1.0.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha1"
	"encoding/hex"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"gopkg.in/yaml.v2"
)

//SecretMap type
type SecretMap map[string]Secret

func AddSecret(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()
	secret := r.FormValue("secret")
	remainingViews, expireAfterViewError := strconv.Atoi(r.FormValue("expireAfterViews"))
	minutesUnitilExpire, expireTimeError := strconv.Atoi(r.FormValue("expireAfter"))

	//Check input
	if secret == "" || expireAfterViewError != nil || expireTimeError != nil {
		w.Header().Set("Content-Type", "application/json; charset=UTF-8")
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	//Create secret
	hash := sha1.New()
	currentTime := time.Now()
	expireTime := currentTime.Add(time.Duration(minutesUnitilExpire) * time.Minute)
	hash.Write([]byte(secret))
	hash.Write([]byte(currentTime.String()))
	hash.Write([]byte(expireTime.String()))
	hashString := hex.EncodeToString(hash.Sum(nil))
	fmt.Println(hashString)
	newSecret := Secret{
		Hash:           hashString,
		SecretText:     secret,
		CreatedAt:      currentTime,
		ExpiresAt:      expireTime,
		RemainingViews: int32(remainingViews),
	}

	var format responseFormat
	switch getResponseFormat() {
	case "xml":
		format = xmlFormat{}
	default:
		format = jsonFormat{}
	}

	data, err := format.marshal(newSecret)
	if err != nil {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	secretMap := getSecretMap()
	secretMap[hashString] = newSecret
	secretMap.save()

	w.Header().Set("Content-Type", format.contentType())
	w.WriteHeader(http.StatusOK)
	w.Write(data)
}

func GetSecretByHash(w http.ResponseWriter, r *http.Request) {
	components := strings.Split(r.URL.Path, "/")
	hash := components[len(components)-1]
	secretMap := getSecretMap()

	if secret, ok := secretMap[hash]; ok {
		if time.Now().After(secret.ExpiresAt) {
			delete(secretMap, hash)
			secretMap.save()
			w.WriteHeader(http.StatusNotFound)
			return
		}

		if secret.RemainingViews <= 0 {
			delete(secretMap, hash)
			secretMap.save()
			w.WriteHeader(http.StatusNotFound)
			return
		}

		secret.RemainingViews--
		fmt.Println(secret)
		secretMap[secret.Hash] = secret
		secretMap.save()

		var format responseFormat
		switch getResponseFormat() {
		case "xml":
			format = xmlFormat{}
		default:
			format = jsonFormat{}
		}
		data, err := format.marshal(secret)
		if err != nil {
			w.WriteHeader(http.StatusNotFound)
			return
		}

		w.Header().Set("Content-Type", format.contentType())
		w.WriteHeader(http.StatusOK)
		w.Write(data)

	} else {
		w.WriteHeader(http.StatusNotFound)
	}
}

type responseFormat interface {
	marshal(Secret) ([]byte, error)
	contentType() string
}

type jsonFormat struct{}

func (f jsonFormat) marshal(s Secret) ([]byte, error) {
	return json.Marshal(s)
}

func (f jsonFormat) contentType() string {
	return "application/json; charset=UTF-8"
}

type xmlFormat struct{}

func (f xmlFormat) marshal(s Secret) ([]byte, error) {
	return xml.MarshalIndent(s, "", " ")
}

func (f xmlFormat) contentType() string {
	return "application/xml; charset=UTF-8"
}

func getResponseFormat() string {
	filename, _ := filepath.Abs("./config.yml")
	yamlFile, readFileError := ioutil.ReadFile(filename)
	if readFileError != nil {
		return "json"
	}

	var config map[string]string
	parsingError := yaml.Unmarshal(yamlFile, &config)
	if parsingError != nil {
		return "json"
	}

	if format, ok := config["responseFormat"]; ok {
		return format
	}

	return "json"
}

func getSecretMap() SecretMap {
	filename, _ := filepath.Abs("./secret.yml")
	data, readFileError := ioutil.ReadFile(filename)
	if readFileError != nil {
		return make(map[string]Secret)
	}

	yamlFile := decrypt(data, "secretPassPhrase")

	var secretMap SecretMap
	parsingError := yaml.Unmarshal(yamlFile, &secretMap)
	if parsingError != nil {
		return make(map[string]Secret)
	}
	return secretMap
}

func (s SecretMap) save() {
	yamlData, error := yaml.Marshal(&s)
	encryptedData := encrypt(yamlData, "secretPassPhrase")
	if error != nil {
		fmt.Println(error)
		return
	}
	ioutil.WriteFile("./secret.yml", encryptedData, 0644)
}

func encrypt(data []byte, passphrase string) []byte {
	block, _ := aes.NewCipher([]byte(passphrase))
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		panic(err.Error())
	}
	nonce := make([]byte, gcm.NonceSize())
	if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
		panic(err.Error())
	}
	ciphertext := gcm.Seal(nonce, nonce, data, nil)
	return ciphertext
}

func decrypt(data []byte, passphrase string) []byte {
	key := []byte(passphrase)
	block, err := aes.NewCipher(key)
	if err != nil {
		panic(err.Error())
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		panic(err.Error())
	}
	nonceSize := gcm.NonceSize()
	nonce, ciphertext := data[:nonceSize], data[nonceSize:]
	plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		panic(err.Error())
	}
	return plaintext
}
